1_start = level 1
	username and NOT encrypted password stored in DB
level 2
	password encrypted
		problem: the secret used in app.js is hard coded -> solution: use environment vars
level 3
	password encrypted, using a 'secret' stored in env var. the secret is used to encrypt the password
	we use dotenv package of node js to use env vars
level 4
	with hashing, we dont need an encryption key. we use a hash function to transform a password into a hash
		advantage of a hash function: it is easy and fast to transform a pw into a hash, but its very hard and time consuming to transform the hash back to the original pw
		the hash will be stored in the DB. when a user logs in, the provided pw by him is hashed with the same function and compared to the stored hash in the DB. if match, user will be logged in
			everytime we hash the string 'test123', the same hash will be the result!
	how hackers can get a users pw even if its hashed?
		they build a hash table and look for users who has the same hash value. this means that these users are using the same password. and then they try the most common passwords like '123456' or 'qwertz'
			or they copy a hash and search for this hash in existing hash tables (generated by other people, also searchable on google...)
level 5
	hashing & salting
		(random) salting is added to the pw and then its hashed. this is good for simple passwords. the salt is also stored in DB (?)
		example: bcrypt is a hashing algo that uses salting (using salt rounds: for example 2 salt rounds means: add 1 salt to pw and hash it, then add 1 salt to the hash and hash it again)
level 6
	cookies and sessions
		needed node packges:
			passport
			passport-local
			passport-local-mongoose
			express-session
level 7 
	oauth 2.0
		we are using passport-google-oauth20, using google as the 3rd party authorizer
		see https://www.passportjs.org/packages/passport-google-oauth20/
		first we create an app on our google account
		on google, config a new app
		save the client id and key! (e.g. in your .env file)